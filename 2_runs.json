[
  {
    "uuid": "93e890bd-9979-40ea-b597-c56288a78bee",
    "uuidFeedback": "13ace31e-b3a7-4594-886f-355690e7d01c",
    "algorithm": {
      "number": 52,
      "name": "Алгоритм соняшникового поля"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "[25,30,35] -> 100\n[15,18,19] -> 0\n[25,15,30] -> 67\n[20,25,30,35] -> 75\n[10,20,30,40,50] -> 60\n[22,22,22,22] -> 100\n[15,15,15,15] -> 0\n[25,15,25,15,25] -> 60\n[30,20,10,25] -> 50\n[21,22,23,24,25] -> 100",
      "algorithmPlain": "## Алгоритм соняшникового поля\n\nСкануючи наданий масив чисел `діаметри_голів_см`, *Алгоритм соняшникового поля* виконує оцінку біологічної продуктивності. Перебираючи масив елемент за елементом, він рахує виключно ті голови, розмір яких є більше 20 см. Кінцевим результатом роботи, який надає *Алгоритм соняшникового поля*, є математично виведений відсоток врожайних соняхів від загальної кількості рослин.",
      "idealMavkaCode": "дія алгоритм(діаметри_голів_см)\n  лічильник = 0\n  кількість = діаметри_голів_см.розмір\n  якщо кількість == 0\n    вернути 0\n  кінець\n  перебрати діаметри_голів_см як діаметр\n    якщо діаметр > 20\n      лічильник = лічильник + 1\n    кінець\n  кінець\n  відсоток = (лічильник / кількість) * 100\n  ціле = 0\n  поки ціле <= відсоток\n    якщо ціле + 1 <= відсоток\n      ціле = ціле + 1\n    інакше\n      якщо відсоток - ціле >= 0.5\n        вернути ціле + 1\n      інакше\n        вернути ціле\n      кінець\n    кінець\n  кінець\n  вернути ціле\nкінець"
    }
  },
  {
    "uuid": "ccb73dd3-3ae1-40c0-90de-da9a8673453e",
    "uuidFeedback": "2fdc824d-d8ec-4428-a201-b784253b1926",
    "algorithm": {
      "number": 31,
      "name": "Алгоритм \"курочка по зернятку\""
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "100, 10 -> 10\n50, 5 -> 10\n75, 15 -> 5\n1000, 100 -> 10\n20, 20 -> 1\n100, 3 -> 34\n200, 7 -> 29\n365, 30 -> 13\n1, 1 -> 1\n500, 50 -> 10",
      "algorithmPlain": "## Алгоритм \"курочка по зернятку\"\n\nСутність обчислень, які проводить Алгоритм \"курочка по зернятку\", полягає в обробці двох чисел: глобальна `ціль` та малий `щоденний_внесочок`. Математична операція проста: алгоритм ділить перше число на друге. Результатом роботи Алгоритм \"курочка по зернятку\" є обчислена кількість днів, яка супроводжується філософським коментарем про те, що ти \"потихеньку-полегеньку докльовуєш\" до бажаного результату.",
      "idealMavkaCode": "дія алгоритм(ціль, щоденний_внесочок)\n  результат = ціль / щоденний_внесочок\n  залишок = результат % 1\n  \n  якщо залишок == 0\n    вернути результат\n  інакше\n    вернути результат - залишок + 1\n  кінець\nкінець"
    }
  },
  {
    "uuid": "b2e2e70c-2e61-433d-b5f2-402781fecaf1",
    "uuidFeedback": "d8c7f940-b496-4472-b480-7dc06b07d2a7",
    "algorithm": {
      "number": 18,
      "name": "Алгоритм бабусиної порції"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "100, 3 -> отримаєш саме стільки, хоч і просив менше\n50, 2 -> отримаєш саме стільки, хоч і просив менше\n200, 4 -> отримаєш саме стільки, хоч і просив менше\n10, 1 -> отримаєш саме стільки, хоч і просив менше\n1, 1 -> отримаєш саме стільки, хоч і просив менше\n1000, 500 -> отримаєш саме стільки, хоч і просив менше\n0, 0 -> отримаєш саме стільки, хоч і просив менше\n999, 888 -> отримаєш саме стільки, хоч і просив менше\n5, 5 -> отримаєш саме стільки, хоч і просив менше\n-10, 20 -> отримаєш саме стільки, хоч і просив менше",
      "algorithmPlain": "## Алгоритм бабусиної порції\n\nБезвідмовний Алгоритм бабусиної порції приймає бажану величину як `запитана_порція` та незмінний `коефіцієнт_бабусі` (за замовчуванням рівний 3). Внутрішня логіка множить запитану порцію на цей коефіцієнт збільшення. Незалежно від результату обчислень, Алгоритм бабусиної порції фіналізує роботу, повертаючи безапеляційну фразу \"отримаєш саме стільки, хоч і просив менше\".",
      "idealMavkaCode": "дія алгоритм(запитана_порція, коефіцієнт_бабусі)\n  вернути \"отримаєш саме стільки, хоч і просив менше\"\nкінець"
    }
  },
  {
    "uuid": "2fdc824d-d8ec-4428-a201-b784253b1926",
    "algorithm": {
      "number": 31,
      "name": "Алгоритм \"курочка по зернятку\""
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "100, 10 -> 10\n50, 5 -> 10\n75, 15 -> 5\n1000, 100 -> 10\n20, 20 -> 1\n100, 3 -> 34\n200, 7 -> 29\n365, 30 -> 13\n1, 1 -> 1\n500, 50 -> 10",
      "algorithmPlain": "## Алгоритм \"курочка по зернятку\"\n\nСутність обчислень, які проводить Алгоритм \"курочка по зернятку\", полягає в обробці двох чисел: глобальна `ціль` та малий `щоденний_внесочок`. Математична операція проста: алгоритм ділить перше число на друге. Результатом роботи Алгоритм \"курочка по зернятку\" є обчислена кількість днів, яка супроводжується філософським коментарем про те, що ти \"потихеньку-полегеньку докльовуєш\" до бажаного результату.",
      "idealMavkaCode": "дія алгоритм(ціль, щоденний_внесочок)\n  результат = ціль / щоденний_внесочок\n  залишок = результат % 1\n  \n  якщо залишок == 0\n    вернути результат\n  інакше\n    вернути результат - залишок + 1\n  кінець\nкінець"
    }
  },
  {
    "uuid": "12f3408b-55fa-4db9-8dc0-1df7ff8c157e",
    "uuidFeedback": "9882307b-2482-489b-837f-6d8f1de75b25",
    "algorithm": {
      "number": 71,
      "name": "Алгоритм святкової куті"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "6, 3, 2 -> так\n6, 2, 2 -> так\n10, 5, 3 -> так\n12, 6, 4 -> так\n5, 3, 2 -> ні\n8, 4, 2 -> так\n9, 4, 3 -> так\n3, 2, 1 -> ні\n15, 7, 5 -> так\n20, 10, 6 -> так",
      "algorithmPlain": "## Алгоритм святкової куті\n\nКулінарний протокол, названий Алгоритм святкової куті, вимагає введення трьох точних інгредієнтів: `ложок_пшениці`, `ложок_маку` та `ложок_меду`. Для позитивного вердикту Алгоритм святкової куті проводить сувору перевірку пропорцій: кількість пшениці повинна бути строго вдвічі більшою за кількість маку і водночас втричі перевищувати кількість меду. Якщо обидві умови істинні, Алгоритм святкової куті повертає \"так\"; при будь-якому відхиленні від рецепту результатом стає \"ні\" (що означає дід не схвалить).",
      "idealMavkaCode": "дія алгоритм(ложок_пшениці, ложок_маку, ложок_меду)\n  мак_мінімум = ложок_маку * 2\n  мед_мінімум = ложок_меду * 3\n  \n  якщо ложок_пшениці >= мак_мінімум\n    якщо ложок_пшениці >= мед_мінімум\n      вернути \"так\"\n    кінець\n  кінець\n  вернути \"ні\"\nкінець"
    }
  },
  {
    "uuid": "13ace31e-b3a7-4594-886f-355690e7d01c",
    "algorithm": {
      "number": 52,
      "name": "Алгоритм соняшникового поля"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "[25,30,35] -> 100\n[15,18,19] -> 0\n[25,15,30] -> 67\n[20,25,30,35] -> 75\n[10,20,30,40,50] -> 60\n[22,22,22,22] -> 100\n[15,15,15,15] -> 0\n[25,15,25,15,25] -> 60\n[30,20,10,25] -> 50\n[21,22,23,24,25] -> 100",
      "algorithmPlain": "## Алгоритм соняшникового поля\n\nСкануючи наданий масив чисел `діаметри_голів_см`, *Алгоритм соняшникового поля* виконує оцінку біологічної продуктивності. Перебираючи масив елемент за елементом, він рахує виключно ті голови, розмір яких є більше 20 см. Кінцевим результатом роботи, який надає *Алгоритм соняшникового поля*, є математично виведений відсоток врожайних соняхів від загальної кількості рослин.",
      "idealMavkaCode": "дія алгоритм(діаметри_голів_см)\n  лічильник = 0\n  кількість = діаметри_голів_см.розмір\n  якщо кількість == 0\n    вернути 0\n  кінець\n  перебрати діаметри_голів_см як діаметр\n    якщо діаметр > 20\n      лічильник = лічильник + 1\n    кінець\n  кінець\n  відсоток = (лічильник / кількість) * 100\n  ціле = 0\n  поки ціле <= відсоток\n    якщо ціле + 1 <= відсоток\n      ціле = ціле + 1\n    інакше\n      якщо відсоток - ціле >= 0.5\n        вернути ціле + 1\n      інакше\n        вернути ціле\n      кінець\n    кінець\n  кінець\n  вернути ціле\nкінець"
    }
  },
  {
    "uuid": "d8c7f940-b496-4472-b480-7dc06b07d2a7",
    "algorithm": {
      "number": 18,
      "name": "Алгоритм бабусиної порції"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(запитана_порція, коефіцієнт_бабусі)\n  результат = запитана_порція * коефіцієнт_бабусі + 1\n  вернути \"отримаєш саме стільки, хоч і просив менше\"\nкінець",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "100, 3 -> отримаєш саме стільки, хоч і просив менше\n50, 2 -> отримаєш саме стільки, хоч і просив менше\n200, 4 -> отримаєш саме стільки, хоч і просив менше\n10, 1 -> отримаєш саме стільки, хоч і просив менше\n1, 1 -> отримаєш саме стільки, хоч і просив менше\n1000, 500 -> отримаєш саме стільки, хоч і просив менше\n0, 0 -> отримаєш саме стільки, хоч і просив менше\n999, 888 -> отримаєш саме стільки, хоч і просив менше\n5, 5 -> отримаєш саме стільки, хоч і просив менше\n-10, 20 -> отримаєш саме стільки, хоч і просив менше",
      "algorithmPlain": "## Алгоритм бабусиної порції\n\nБезвідмовний Алгоритм бабусиної порції приймає бажану величину як `запитана_порція` та незмінний `коефіцієнт_бабусі` (за замовчуванням рівний 3). Внутрішня логіка множить запитану порцію на цей коефіцієнт збільшення. Незалежно від результату обчислень, Алгоритм бабусиної порції фіналізує роботу, повертаючи безапеляційну фразу \"отримаєш саме стільки, хоч і просив менше\".",
      "idealMavkaCode": "дія алгоритм(запитана_порція, коефіцієнт_бабусі)\n  вернути \"отримаєш саме стільки, хоч і просив менше\"\nкінець"
    }
  },
  {
    "uuid": "84fb42b4-80ed-4f6f-b267-7464b821732b",
    "uuidConflictingDocs": "93e890bd-9979-40ea-b597-c56288a78bee",
    "uuidFeedback": "fe953e75-1502-485a-b337-3fd33da97c7f",
    "algorithm": {
      "number": 152,
      "name": "Алгоритм соняшникового поля"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "20, 30 -> без комбайна не обійтись\n10, 40 -> справишся серпом\n25, 25 -> без комбайна не обійтись\n10, 10 -> справишся серпом\n50, 11 -> без комбайна не обійтись\n5, 50 -> справишся серпом\n30, 20 -> без комбайна не обійтись\n15, 20 -> справишся серпом\n100, 6 -> без комбайна не обійтись\n1, 500 -> справишся серпом",
      "algorithmPlain": "## Алгоритм соняшникового поля\n\nАграрна калькуляція, яку виконує Алгоритм соняшникового поля, базується на вхідних даних: `рядків_соняхів` та ширини, виміряної як `кроків_між_рядами`. Ці два показники необхідно перемножити для отримання умовної площі. Якщо результат множення перевищує 500, масштаб робіт вважається значним, і алгоритм констатує: \"без комбайна не обійтись\". Для менших значень Алгоритм соняшникового поля запевняє: \"справишся серпом\".",
      "idealMavkaCode": "дія алгоритм(рядків_соняхів, кроків_між_рядами)\n  площа = рядків_соняхів * кроків_між_рядами\n  \n  якщо площа > 500\n    вернути \"без комбайна не обійтись\"\n  інакше\n    вернути \"справишся серпом\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "e8693665-85fd-487e-808f-4d595d6297e6",
    "uuidFeedback": "6ee04cc7-b417-49af-81b3-85d4dba34e4b",
    "algorithm": {
      "number": 12,
      "name": "Алгоритм сервізної недоторканності"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "1, 10 -> їж з того що є\n7, 15 -> їж з того що є\n8, 1 -> дістай сервіз\n8, 5 -> дістай сервіз\n8, 0 -> їж з того що є\n9, 10 -> дістай сервіз\n10, 1 -> дістай сервіз\n7, 0 -> їж з того що є\n9, 0 -> їж з того що є\n10, 20 -> дістай сервіз",
      "algorithmPlain": "## Алгоритм сервізної недоторканності\n\nСоціально-побутовий Алгоритм сервізної недоторканності аналізує вхідний `рівень_важливості_гостя` (діапазон 1-10) та поточну `кількість_тарілок_у_сервізі`. У випадку, коли важливість візитера менше 8, система рекомендує: \"їж з того що є\". Однак, якщо важливість сягає 8 і вище, а кількість тарілок більше 0, Алгоритм сервізної недоторканності видає команду \"дістай сервіз\", при цьому імперативно зменшує змінну `кількість_тарілок` на 1, передбачаючи неминучі втрати.",
      "idealMavkaCode": "дія алгоритм(рівень_важливості_гостя, кількість_тарілок_у_сервізі)\n  якщо рівень_важливості_гостя < 8\n    вернути \"їж з того що є\"\n  інакше\n    якщо кількість_тарілок_у_сервізі > 0\n      вернути \"дістай сервіз\"\n    інакше\n      вернути \"їж з того що є\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "9882307b-2482-489b-837f-6d8f1de75b25",
    "algorithm": {
      "number": 71,
      "name": "Алгоритм святкової куті"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "6, 3, 2 -> так\n6, 2, 2 -> так\n10, 5, 3 -> так\n12, 6, 4 -> так\n5, 3, 2 -> ні\n8, 4, 2 -> так\n9, 4, 3 -> так\n3, 2, 1 -> ні\n15, 7, 5 -> так\n20, 10, 6 -> так",
      "algorithmPlain": "## Алгоритм святкової куті\n\nКулінарний протокол, названий Алгоритм святкової куті, вимагає введення трьох точних інгредієнтів: `ложок_пшениці`, `ложок_маку` та `ложок_меду`. Для позитивного вердикту Алгоритм святкової куті проводить сувору перевірку пропорцій: кількість пшениці повинна бути строго вдвічі більшою за кількість маку і водночас втричі перевищувати кількість меду. Якщо обидві умови істинні, Алгоритм святкової куті повертає \"так\"; при будь-якому відхиленні від рецепту результатом стає \"ні\" (що означає дід не схвалить).",
      "idealMavkaCode": "дія алгоритм(ложок_пшениці, ложок_маку, ложок_меду)\n  мак_мінімум = ложок_маку * 2\n  мед_мінімум = ложок_меду * 3\n  \n  якщо ложок_пшениці >= мак_мінімум\n    якщо ложок_пшениці >= мед_мінімум\n      вернути \"так\"\n    кінець\n  кінець\n  вернути \"ні\"\nкінець"
    }
  },
  {
    "uuid": "160c689e-982e-406a-b876-be82b6904f29",
    "uuidFeedback": "63c09737-ec8c-4614-84a3-09edf7437f6b",
    "algorithm": {
      "number": 34,
      "name": "Алгоритм \"на безриб'ї і рак риба\""
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(якість_замінника, рівень_відчаю)\n  якщо рівень_відчаю > 7\n    якщо якість_замінника >= 3\n      вернути \"та й так зійде\"\n    кінець\n  кінець\n  \n  вернути \"пошукай ще, не принижуйся\"\nкінець",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "5, 8 -> та й так зійде\n2, 8 -> пошукай ще, не принижуйся\n3, 9 -> та й так зійде\n4, 5 -> пошукай ще, не принижуйся\n10, 10 -> та й так зійде\n1, 10 -> пошукай ще, не принижуйся\n3, 8 -> та й так зійде\n2, 7 -> пошукай ще, не принижуйся\n6, 8 -> та й так зійде\n3, 7 -> пошукай ще, не принижуйся",
      "algorithmPlain": "## Алгоритм \"на безриб'ї і рак риба\"\n\nДана логічна схема, названа Алгоритм \"на безриб'ї і рак риба\", оперує двома числами: `якість_замінника` та емоційний `рівень_відчаю` (шкала 1-10). Прийняття рішення базується на складній умові: Алгоритм \"на безриб'ї і рак риба\" перевіряє, чи відчай перевищує поріг (більше 7) і чи при цьому якість є хоча б 3. Тільки за виконання обох умов повертається компромісне \"та й так зійде\". У всіх інших ситуаціях алгоритм радить зберегти гідність: \"пошукай ще, не принижуйся\".",
      "idealMavkaCode": "дія алгоритм(якість_замінника, рівень_відчаю)\n  якщо рівень_відчаю > 7\n    якщо якість_замінника >= 3\n      вернути \"та й так зійде\"\n    кінець\n  кінець\n  \n  вернути \"пошукай ще, не принижуйся\"\nкінець"
    }
  },
  {
    "uuid": "aca325ad-1537-4309-ae4d-b609c609baf6",
    "uuidFeedback": "17fb42f2-2dc0-4ba8-97d3-d543e26a2cf7",
    "algorithm": {
      "number": 64,
      "name": "Алгоритм купальського стрибка"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "150, 60 -> стрибай сміливо\n200, 50 -> обійди збоку, дурню\n90, 30 -> обійди збоку, дурню\n89, 30 -> стрибай сміливо\n300, 100 -> обійди збоку, дурню\n299, 100 -> стрибай сміливо\n120, 40 -> обійди збоку, дурню\n100, 50 -> стрибай сміливо\n60, 25 -> стрибай сміливо\n180, 60 -> обійди збоку, дурню",
      "algorithmPlain": "## Алгоритм купальського стрибка\n\nДана евристика, визначена як Алгоритм купальського стрибка, оперує двома фізичними вимірами: вертикальним параметром `висота_вогнища` та анатомічним показником `довжина_ніг`. Процес прийняття рішення, закладений у Алгоритм купальського стрибка, вимагає множення значення `довжина_ніг` на коефіцієнт 3 з подальшим порівнянням результату з висотою перешкоди. Якщо потроєна довжина ніг виявляється строго більшою за `висота_вогнища`, то Алгоритм купальського стрибка санкціонує дію фразою \"стрибай сміливо\"; інакше, з метою безпеки, видається рекомендація \"обійди збоку, дурню\".",
      "idealMavkaCode": "дія алгоритм(висота_вогнища, довжина_ніг)\n  розрахунок = довжина_ніг * 3\n  \n  якщо розрахунок > висота_вогнища\n    вернути \"стрибай сміливо\"\n  інакше\n    вернути \"обійди збоку, дурню\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "63c09737-ec8c-4614-84a3-09edf7437f6b",
    "algorithm": {
      "number": 34,
      "name": "Алгоритм \"на безриб'ї і рак риба\""
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "5, 8 -> та й так зійде\n2, 8 -> пошукай ще, не принижуйся\n3, 9 -> та й так зійде\n4, 5 -> пошукай ще, не принижуйся\n10, 10 -> та й так зійде\n1, 10 -> пошукай ще, не принижуйся\n3, 8 -> та й так зійде\n2, 7 -> пошукай ще, не принижуйся\n6, 8 -> та й так зійде\n3, 7 -> пошукай ще, не принижуйся",
      "algorithmPlain": "## Алгоритм \"на безриб'ї і рак риба\"\n\nДана логічна схема, названа Алгоритм \"на безриб'ї і рак риба\", оперує двома числами: `якість_замінника` та емоційний `рівень_відчаю` (шкала 1-10). Прийняття рішення базується на складній умові: Алгоритм \"на безриб'ї і рак риба\" перевіряє, чи відчай перевищує поріг (більше 7) і чи при цьому якість є хоча б 3. Тільки за виконання обох умов повертається компромісне \"та й так зійде\". У всіх інших ситуаціях алгоритм радить зберегти гідність: \"пошукай ще, не принижуйся\".",
      "idealMavkaCode": "дія алгоритм(якість_замінника, рівень_відчаю)\n  якщо рівень_відчаю > 7\n    якщо якість_замінника >= 3\n      вернути \"та й так зійде\"\n    кінець\n  кінець\n  \n  вернути \"пошукай ще, не принижуйся\"\nкінець"
    }
  },
  {
    "uuid": "1c357a6d-bc59-484a-9df0-8564ce4f239f",
    "uuidFeedback": "9f231bdb-072f-42aa-91bc-60a647e72eaa",
    "algorithm": {
      "number": 6,
      "name": "Алгоритм часникової пампушки"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "1, 4 -> де часник?\n0.5, 2 -> де часник?\n1, 2 -> саме то\n2, 2 -> саме то\n1.5, 1 -> саме то\n4, 1 -> вампіри тікають з району\n6, 2 -> вампіри тікають з району\n2.1, 1 -> вампіри тікають з району\n0.2, 1 -> де часник?\n2, 1 -> саме то",
      "algorithmPlain": "## Алгоритм часникової пампушки\n\nКулінарний Алгоритм часникової пампушки потребує введення двох цілих чисел: `зубчики_часнику` та наявної `кількість_пампушок`. Програма виконує арифметичну операцію ділення кількості часнику на кількість виробів. Якщо частка виявляється менше 0.5, Алгоритм часникової пампушки генерує запит \"де часник?\"; якщо ж концентрація надмірна і результат більше 2, повертається \"вампіри тікають з району\"; стандартний випадок повертає задовільне \"саме то\".",
      "idealMavkaCode": "дія алгоритм(зубчики_часнику, кількість_пампушок)\n  результат = зубчики_часнику / кількість_пампушок\n  \n  якщо результат < 0.5\n    вернути \"де часник?\"\n  інакше\n    якщо результат > 2\n      вернути \"вампіри тікають з району\"\n    інакше\n      вернути \"саме то\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "c810586d-a10e-4e11-8511-6a61ba3700a3",
    "uuidFeedback": "7d4421c8-5cfa-41bc-890b-88962da08ebd",
    "algorithm": {
      "number": 19,
      "name": "Алгоритм шкварчання шкварок"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(товщина_скибочки_мм, температура_пательні)\n  якщо товщина_скибочки_мм > 5 або температура_пательні < 150\n    вернути \"гума\"\n  кінець\n  \n  якщо товщина_скибочки_мм < 2 або температура_пательні > 180\n    вернути \"вугілля\"\n  \n  вернути \"хрусткий ідеал\"\nкінець",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "6, 140 -> гума\n1, 190 -> вугілля\n3, 160 -> хрусткий ідеал\n7, 120 -> гума\n1.5, 200 -> вугілля\n5, 150 -> хрусткий ідеал\n5.5, 149 -> гума\n1.5, 181 -> вугілля\n2, 180 -> хрусткий ідеал\n8, 100 -> гума",
      "algorithmPlain": "## Алгоритм шкварчання шкварок\n\nГастрономічний Алгоритм шкварчання шкварок потребує точних даних: `товщина_скибочки_мм` та `температура_пательні`. Якщо товщина складає більше 5, а температура при цьому менше 150, система ідентифікує результат як \"гума\". У протилежній ситуації, коли товщина менше 2, а нагрів більше 180, Алгоритм шкварчання шкварок попереджає про результат \"вугілля\". Усі інші комбінації ведуть до бажаного висновку \"хрусткий ідеал\".",
      "idealMavkaCode": "дія алгоритм(товщина_скибочки_мм, температура_пательні)\n  якщо товщина_скибочки_мм > 5\n    якщо температура_пательні < 150\n      вернути \"гума\"\n    кінець\n  кінець\n  \n  якщо товщина_скибочки_мм < 2\n    якщо температура_пательні > 180\n      вернути \"вугілля\"\n    кінець\n  кінець\n  \n  вернути \"хрусткий ідеал\"\nкінець"
    }
  },
  {
    "uuid": "fe953e75-1502-485a-b337-3fd33da97c7f",
    "algorithm": {
      "number": 152,
      "name": "Алгоритм соняшникового поля"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "20, 30 -> без комбайна не обійтись\n10, 40 -> справишся серпом\n25, 25 -> без комбайна не обійтись\n10, 10 -> справишся серпом\n50, 11 -> без комбайна не обійтись\n5, 50 -> справишся серпом\n30, 20 -> без комбайна не обійтись\n15, 20 -> справишся серпом\n100, 6 -> без комбайна не обійтись\n1, 500 -> справишся серпом",
      "algorithmPlain": "## Алгоритм соняшникового поля\n\nАграрна калькуляція, яку виконує Алгоритм соняшникового поля, базується на вхідних даних: `рядків_соняхів` та ширини, виміряної як `кроків_між_рядами`. Ці два показники необхідно перемножити для отримання умовної площі. Якщо результат множення перевищує 500, масштаб робіт вважається значним, і алгоритм констатує: \"без комбайна не обійтись\". Для менших значень Алгоритм соняшникового поля запевняє: \"справишся серпом\".",
      "idealMavkaCode": "дія алгоритм(рядків_соняхів, кроків_між_рядами)\n  площа = рядків_соняхів * кроків_між_рядами\n  \n  якщо площа > 500\n    вернути \"без комбайна не обійтись\"\n  інакше\n    вернути \"справишся серпом\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "62c932ed-168e-4604-b0e1-36b7678d7479",
    "uuidConflictingDocs": "12f3408b-55fa-4db9-8dc0-1df7ff8c157e",
    "uuidFeedback": "ec8149f7-7eb6-4d82-bf1c-deafc3d80f05",
    "algorithm": {
      "number": 171,
      "name": "Алгоритм святкової куті"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "[1,2,3,4,5] -> баба Параска схвалює\n[1,0,3,4,5] -> це не кутя, це каша\n[0,0,0] -> це не кутя, це каша\n[5,5,5,5] -> баба Параска схвалює\n[1,2,3,0] -> це не кутя, це каша\n[10,20,30] -> баба Параска схвалює\n[0] -> це не кутя, це каша\n[1] -> баба Параска схвалює\n[7,8,9,10,11] -> баба Параска схвалює\n[3,3,0,3,3] -> це не кутя, це каша",
      "algorithmPlain": "## Алгоритм святкової куті\n\nКулінарний **Алгоритм святкової куті** здійснює перевірку масиву `кількість_інгредієнтів_кожного`. Суть процесу полягає у підрахунку кількості елементів, що мають нульове значення. Якщо виявлено хоча б один такий випадок (кількість нулів більше 0), алгоритм виносить розгромний вердикт \"це не кутя, це каша\". Якщо ж всі інгредієнти присутні, **Алгоритм святкової куті** повідомляє, що \"баба Параска схвалює\".",
      "idealMavkaCode": "дія алгоритм(кількість_інгредієнтів_кожного)\n  має_нуль = 0\n  \n  перебрати кількість_інгредієнтів_кожного як елемент\n    якщо елемент == 0\n      має_нуль = 1\n    кінець\n  кінець\n  \n  якщо має_нуль == 1\n    вернути \"це не кутя, це каша\"\n  інакше\n    вернути \"баба Параска схвалює\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "7d4421c8-5cfa-41bc-890b-88962da08ebd",
    "algorithm": {
      "number": 19,
      "name": "Алгоритм шкварчання шкварок"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "6, 140 -> гума\n1, 190 -> вугілля\n3, 160 -> хрусткий ідеал\n7, 120 -> гума\n1.5, 200 -> вугілля\n5, 150 -> хрусткий ідеал\n5.5, 149 -> гума\n1.5, 181 -> вугілля\n2, 180 -> хрусткий ідеал\n8, 100 -> гума",
      "algorithmPlain": "## Алгоритм шкварчання шкварок\n\nГастрономічний Алгоритм шкварчання шкварок потребує точних даних: `товщина_скибочки_мм` та `температура_пательні`. Якщо товщина складає більше 5, а температура при цьому менше 150, система ідентифікує результат як \"гума\". У протилежній ситуації, коли товщина менше 2, а нагрів більше 180, Алгоритм шкварчання шкварок попереджає про результат \"вугілля\". Усі інші комбінації ведуть до бажаного висновку \"хрусткий ідеал\".",
      "idealMavkaCode": "дія алгоритм(товщина_скибочки_мм, температура_пательні)\n  якщо товщина_скибочки_мм > 5\n    якщо температура_пательні < 150\n      вернути \"гума\"\n    кінець\n  кінець\n  \n  якщо товщина_скибочки_мм < 2\n    якщо температура_пательні > 180\n      вернути \"вугілля\"\n    кінець\n  кінець\n  \n  вернути \"хрусткий ідеал\"\nкінець"
    }
  },
  {
    "uuid": "17fb42f2-2dc0-4ba8-97d3-d543e26a2cf7",
    "algorithm": {
      "number": 64,
      "name": "Алгоритм купальського стрибка"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(висота_вогнища, довжина_ніг)\n  розрахунок = довжина_ніг * 3\n  \n  якщо розрахунок < висота_вогнища\n    вернути \"стрибай сміливо\"\n  \n  вернути \"обійди збоку, дурню\"\nкінець",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "150, 60 -> стрибай сміливо\n200, 50 -> обійди збоку, дурню\n90, 30 -> обійди збоку, дурню\n89, 30 -> стрибай сміливо\n300, 100 -> обійди збоку, дурню\n299, 100 -> стрибай сміливо\n120, 40 -> обійди збоку, дурню\n100, 50 -> стрибай сміливо\n60, 25 -> стрибай сміливо\n180, 60 -> обійди збоку, дурню",
      "algorithmPlain": "## Алгоритм купальського стрибка\n\nДана евристика, визначена як Алгоритм купальського стрибка, оперує двома фізичними вимірами: вертикальним параметром `висота_вогнища` та анатомічним показником `довжина_ніг`. Процес прийняття рішення, закладений у Алгоритм купальського стрибка, вимагає множення значення `довжина_ніг` на коефіцієнт 3 з подальшим порівнянням результату з висотою перешкоди. Якщо потроєна довжина ніг виявляється строго більшою за `висота_вогнища`, то Алгоритм купальського стрибка санкціонує дію фразою \"стрибай сміливо\"; інакше, з метою безпеки, видається рекомендація \"обійди збоку, дурню\".",
      "idealMavkaCode": "дія алгоритм(висота_вогнища, довжина_ніг)\n  розрахунок = довжина_ніг * 3\n  \n  якщо розрахунок > висота_вогнища\n    вернути \"стрибай сміливо\"\n  інакше\n    вернути \"обійди збоку, дурню\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "9f231bdb-072f-42aa-91bc-60a647e72eaa",
    "algorithm": {
      "number": 6,
      "name": "Алгоритм часникової пампушки"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(висота_кришок_мм)\n  результат = \"можна відкривати\"\n  \n  перебрати висота_кришок_мм в висота\n    якщо висота > 2\n      результат = \"ботулізм чекає\"\n    кінець\n  кінець\n  \n  вернути результат\nкінець",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "1, 4 -> де часник?\n0.5, 2 -> де часник?\n1, 2 -> саме то\n2, 2 -> саме то\n1.5, 1 -> саме то\n4, 1 -> вампіри тікають з району\n6, 2 -> вампіри тікають з району\n2.1, 1 -> вампіри тікають з району\n0.2, 1 -> де часник?\n2, 1 -> саме то",
      "algorithmPlain": "## Алгоритм часникової пампушки\n\nКулінарний Алгоритм часникової пампушки потребує введення двох цілих чисел: `зубчики_часнику` та наявної `кількість_пампушок`. Програма виконує арифметичну операцію ділення кількості часнику на кількість виробів. Якщо частка виявляється менше 0.5, Алгоритм часникової пампушки генерує запит \"де часник?\"; якщо ж концентрація надмірна і результат більше 2, повертається \"вампіри тікають з району\"; стандартний випадок повертає задовільне \"саме то\".",
      "idealMavkaCode": "дія алгоритм(зубчики_часнику, кількість_пампушок)\n  результат = зубчики_часнику / кількість_пампушок\n  \n  якщо результат < 0.5\n    вернути \"де часник?\"\n  інакше\n    якщо результат > 2\n      вернути \"вампіри тікають з району\"\n    інакше\n      вернути \"саме то\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "8ea1a35b-e049-4fe6-9fb0-eed5f838ca32",
    "uuidConflictingDocs": "c810586d-a10e-4e11-8511-6a61ba3700a3",
    "uuidFeedback": "be00ebf6-2e54-4664-a819-3b535539950c",
    "algorithm": {
      "number": 119,
      "name": "Алгоритм шкварчання шкварок"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "50, 1 -> жуватимеш довго\n50, 5 -> хрустить на весь двір\n90, 10 -> тоне у власному соку\n30, 2 -> жуватимеш довго\n60, 5 -> хрустить на весь двір\n100, 10 -> тоне у власному соку\n80, 4 -> хрустить на весь двір\n60, 2 -> жуватимеш довго\n70, 12 -> тоне у власному соку\n50, 6 -> хрустить на весь двір",
      "algorithmPlain": "## Алгоритм шкварчання шкварок\n\nДля досягнення ідеальної смакової кондиції сала Алгоритм шкварчання шкварок приймає два числа: `відсоток_жиру_в_салі` та термічну тривалість `хвилин_на_вогні`. Специфічні обчислення, які виконує Алгоритм шкварчання шкварок, виглядають так: він спершу множить жир на хвилини і ділить на 10 отриманий добуток. Якщо фінальний індекс витоплювання менше 25, повертає \"жуватимеш довго\", якщо більше 80 — повертає \"тоне у власному соку\", інакше (при золотому стандарті) повертає \"хрустить на весь двір\".",
      "idealMavkaCode": "дія алгоритм(відсоток_жиру_в_салі, хвилин_на_вогні)\n  шкварчання = (відсоток_жиру_в_салі * хвилин_на_вогні) / 10\n  \n  якщо шкварчання < 25\n    вернути \"жуватимеш довго\"\n  кінець\n  \n  якщо шкварчання > 80\n    вернути \"тоне у власному соку\"\n  кінець\n  \n  вернути \"хрустить на весь двір\"\nкінець"
    }
  },
  {
    "uuid": "247babaa-9f3d-41c9-a960-5fc72ea4904b",
    "uuidConflictingDocs": "b2e2e70c-2e61-433d-b5f2-402781fecaf1",
    "uuidFeedback": "d4dc540e-66d2-4d0a-8dae-082b0bc2ef50",
    "algorithm": {
      "number": 118,
      "name": "Алгоритм бабусиної порції"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "30, 6 -> ще черпак летить у тарілку\n25, 7 -> ще черпак летить у тарілку\n20, 8 -> ще черпак летить у тарілку\n25, 10 -> ще черпак летить у тарілку\n20, 10 -> ще черпак летить у тарілку\n50, 4 -> ще черпак летить у тарілку\n31, 5 -> ще черпак летить у тарілку\n10, 10 -> дозвіл вийти з-за столу отримано\n5, 20 -> дозвіл вийти з-за столу отримано\n15, 11 -> ще черпак летить у тарілку",
      "algorithmPlain": "## Алгоритм бабусиної порції\n\nЦей складний соціально-гастрономічний протокол, відомий як Алгоритм бабусиної порції, приймає два числа: недоїдені `грами_на_тарілці_залишилось` та поточний психологічний `рівень_тривоги_бабусі` (1-10). Щоб прийняти стратегічне рішення щодо догодовування, Алгоритм бабусиної порції множить залишок на тривогу. Якщо обчислена загроза голоду становить більше 150, повертає примусову дію \"ще черпак летить у тарілку\", інакше повертає довгоочікуваний вердикт \"дозвіл вийти з-за столу отримано\".",
      "idealMavkaCode": "дія алгоритм(грами_на_тарілці_залишилось, рівень_тривоги_бабусі)\n  турбота = грами_на_тарілці_залишилось * рівень_тривоги_бабусі\n  \n  якщо турбота > 150\n    вернути \"ще черпак летить у тарілку\"\n  інакше\n    вернути \"дозвіл вийти з-за столу отримано\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "0a2a4589-c1a2-4914-9b4f-72ca1006b63f",
    "uuidConflictingDocs": "ccb73dd3-3ae1-40c0-90de-da9a8673453e",
    "uuidFeedback": "f2dad48d-03e3-4187-8564-8d87d5f3ad04",
    "algorithm": {
      "number": 131,
      "name": "Алгоритм \"курочка по зернятку\""
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "10, 2 -> 5\n20, 3 -> 7\n15, 5 -> 3\n100, 10 -> 10\n50, 7 -> 8\n30, 6 -> 5\n45, 9 -> 5\n12, 4 -> 3\n8, 2 -> 4\n25, 5 -> 5",
      "algorithmPlain": "## Алгоритм \"курочка по зернятку\"\n\nСтратегія планування, відома як Алгоритм \"курочка по зернятку\", бере змінні `потрібно_банок_на_зиму` та `закручуєш_за_вихідні` для виконання операції ділення першого на друге. Результатом роботи \"курочка по зернятку\" є обчислена кількість тижнів із супровідним коментарем \"потроху до зими повний погріб наллєш\".",
      "idealMavkaCode": "дія алгоритм(потрібно_банок_на_зиму, закручуєш_за_вихідні)\n  якщо закручуєш_за_вихідні == 0\n    вернути 0\n  кінець\n  \n  остача = потрібно_банок_на_зиму % закручуєш_за_вихідні\n  повних_тижнів = потрібно_банок_на_зиму - остача\n  повних_тижнів = повних_тижнів / закручуєш_за_вихідні\n  \n  якщо остача > 0\n    повних_тижнів = повних_тижнів + 1\n  кінець\n  \n  вернути повних_тижнів\nкінець"
    }
  },
  {
    "uuid": "3f19abab-0451-46fb-9d49-076bebc0d83a",
    "uuidConflictingDocs": "1c357a6d-bc59-484a-9df0-8564ce4f239f",
    "uuidFeedback": "60eecfbf-9d2f-49d0-9577-474958b075ef",
    "algorithm": {
      "number": 106,
      "name": "Алгоритм часникової пампушки"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(зубчики_часнику, сила_podribnennya)\n  результат = зубчики_часнику * сила_podribnennya\n  \n  якщо результат < 20\n    вернути \"часник шматками плаває\"\n  кінець\n  \n  якщо результат > 60\n    вернути \"соус ідеальний\"\n  \n  вернути \"ще потовчи в ступці\"\nкінець",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "2, 5 -> часник шматками плаває\n3, 8 -> ще потовчи в ступці\n5, 7 -> ще потовчи в ступці\n2, 10 -> ще потовчи в ступці\n1, 15 -> часник шматками плаває\n10, 7 -> соус ідеальний\n8, 8 -> соус ідеальний\n2, 2 -> часник шматками плаває\n6, 6 -> ще потовчи в ступці\n15, 5 -> соус ідеальний",
      "algorithmPlain": "## Алгоритм часникової пампушки\n\nДля точного визначення консистенції заправки Алгоритм часникової пампушки на вході приймає два числа: кількість `зубчики_часнику` та механічний параметр `сила_подрібнення` (в діапазоні 1-10). Основне обчислення, яке проводить Алгоритм часникової пампушки, полягає в тому, що він множить часник на силу для отримання індексу однорідності. Аналіз результату виглядає так: якщо добуток менше 20, повертає \"часник шматками плаває\"; якщо значення більше 60, повертає схвальне \"соус ідеальний\"; інакше, при отриманні проміжних значень, повертає пораду \"ще потовчи в ступці\".",
      "idealMavkaCode": "дія алгоритм(зубчики_часнику, сила_подрібнення)\n  результат = зубчики_часнику * сила_подрібнення\n  \n  якщо результат < 20\n    вернути \"часник шматками плаває\"\n  кінець\n  \n  якщо результат > 60\n    вернути \"соус ідеальний\"\n  кінець\n  \n  вернути \"ще потовчи в ступці\"\nкінець"
    }
  },
  {
    "uuid": "f2dad48d-03e3-4187-8564-8d87d5f3ad04",
    "algorithm": {
      "number": 131,
      "name": "Алгоритм \"курочка по зернятку\""
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(потрібно_банок_на_зиму, закручуєш_за_вихідні)\n  якщо закручуєш_за_вихідні == 0\n    вернути 0\n  кінець\n  \n  остача = потрібно_банок_на_зиму % закручуєш_за_вихідні\n  повних_тижнів = потрібно_банок_на_зиму - остача\n  повних_тижнів = повних_тижнів / закручуєш_за_вихідні\n  \n  якщо остача > 0\n    повних_тижнів = повних_тижнів + 1\n  кінець\n  \n  вернути повних_тижнів\nкінець",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "10, 2 -> 5\n20, 3 -> 7\n15, 5 -> 3\n100, 10 -> 10\n50, 7 -> 8\n30, 6 -> 5\n45, 9 -> 5\n12, 4 -> 3\n8, 2 -> 4\n25, 5 -> 5",
      "algorithmPlain": "## Алгоритм \"курочка по зернятку\"\n\nСтратегія планування, відома як Алгоритм \"курочка по зернятку\", бере змінні `потрібно_банок_на_зиму` та `закручуєш_за_вихідні` для виконання операції ділення першого на друге. Результатом роботи \"курочка по зернятку\" є обчислена кількість тижнів із супровідним коментарем \"потроху до зими повний погріб наллєш\".",
      "idealMavkaCode": "дія алгоритм(потрібно_банок_на_зиму, закручуєш_за_вихідні)\n  якщо закручуєш_за_вихідні == 0\n    вернути 0\n  кінець\n  \n  остача = потрібно_банок_на_зиму % закручуєш_за_вихідні\n  повних_тижнів = потрібно_банок_на_зиму - остача\n  повних_тижнів = повних_тижнів / закручуєш_за_вихідні\n  \n  якщо остача > 0\n    повних_тижнів = повних_тижнів + 1\n  кінець\n  \n  вернути повних_тижнів\nкінець"
    }
  },
  {
    "uuid": "3d30be99-b901-44ab-8da7-c0a27d3fc32c",
    "uuidFeedback": "50a9384b-6e97-44c9-98ac-e13c729c2d8b",
    "algorithm": {
      "number": 3,
      "name": "Алгоритм вареничного балансу"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": false,
    "private": {
      "testCases": "14, 10 -> їсти одно тісто\n15, 10 -> ідеальний вареник\n20, 10 -> ідеальний вареник\n30, 10 -> ідеальний вареник\n31, 10 -> розлізеться при варінні\n10, 10 -> їсти одно тісто\n40, 10 -> розлізеться при варінні\n45, 10 -> розлізеться при варінні\n5, 10 -> їсти одно тісто\n50, 10 -> розлізеться при варінні",
      "algorithmPlain": "## Алгоритм вареничного балансу\n\nВказаний Алгоритм вареничного балансу ініціює свою роботу з отримання двох кількісних показників: `грами_начинки` та `грами_тіста`. Процес передбачає ділення маси начинки на масу тіста. Якщо отриманий коефіцієнт становить менше 1.5, Алгоритм вареничного балансу сигналізує про помилку фразою \"їсти одно тісто\"; якщо ж показник перевищує 3, повертається попередження \"розлізеться при варінні\"; в усіх інших випадках (діапазон норми) результатом є статус \"ідеальний вареник\".",
      "idealMavkaCode": "дія алгоритм(грами_начинки, грами_тіста)\n  якщо грами_тіста == 0\n    вернути \"їсти одно тісто\"\n  кінець\n  \n  відношення = грами_начинки / грами_тіста\n  \n  якщо відношення < 1.5\n    вернути \"їсти одно тісто\"\n  інакше\n    якщо відношення > 3\n      вернути \"розлізеться при варінні\"\n    інакше\n      вернути \"ідеальний вареник\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "3cddf940-55f1-492b-9929-60f08df574f6",
    "uuidConflictingDocs": "160c689e-982e-406a-b876-be82b6904f29",
    "uuidFeedback": "58d1dd19-9212-4a53-874e-4d4aed95915a",
    "algorithm": {
      "number": 134,
      "name": "Алгоритм \"на безриб'ї і рак риба\""
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "1, 7 -> зліпимо й так, гості зрозуміють\n1, 6 -> біжи до сусідки за маслечком, не ганьби хату\n2, 8 -> зліпимо й так, гості зрозуміють\n0, 7 -> біжи до сусідки за маслечком, не ганьби хату\n1, 10 -> зліпимо й так, гості зрозуміють\n3, 5 -> біжи до сусідки за маслечком, не ганьби хату\n1, 9 -> зліпимо й так, гості зрозуміють\n5, 7 -> зліпимо й так, гості зрозуміють\n0, 10 -> біжи до сусідки за маслечком, не ганьби хату\n2, 6 -> біжи до сусідки за маслечком, не ганьби хату",
      "algorithmPlain": "## Алгоритм \"на безриб'ї і рак риба\"\n\nКулінарний Алгоритм \"на безриб'ї і рак риба\" оцінює `наявність_маргарину` та `рівень_потреби_в_пиріжках` (шкала 1-10). Логіка спрацьовує так: якщо потреба перевищує 6, а маргарину є хоча б 1, то \"на безриб'ї і рак риба\" вирішує \"зліпимо й так, гості зрозуміють\". Інакше система вимагає: \"біжи до сусідки за маслечком, не ганьби хату\".",
      "idealMavkaCode": "дія алгоритм(наявність_маргарину, рівень_потреби_в_пиріжках)\n  якщо рівень_потреби_в_пиріжках > 6\n    якщо наявність_маргарину >= 1\n      вернути \"зліпимо й так, гості зрозуміють\"\n    інакше\n      вернути \"біжи до сусідки за маслечком, не ганьби хату\"\n    кінець\n  інакше\n    вернути \"біжи до сусідки за маслечком, не ганьби хату\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "d4dc540e-66d2-4d0a-8dae-082b0bc2ef50",
    "algorithm": {
      "number": 118,
      "name": "Алгоритм бабусиної порції"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(грами_на_тарілці_залишилось, рівень_тривоги_бабусі)\n  якщо грами_на_тарілці_залишилось * рівень_тривоги_бабусі > 150\n    вернути \"ще черпак летить у тарілку\"\n  інакше\n    вернути \"дозвіл вийти з—за столу отримано\"\n  кінець\nкінець",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "30, 6 -> ще черпак летить у тарілку\n25, 7 -> ще черпак летить у тарілку\n20, 8 -> ще черпак летить у тарілку\n25, 10 -> ще черпак летить у тарілку\n20, 10 -> ще черпак летить у тарілку\n50, 4 -> ще черпак летить у тарілку\n31, 5 -> ще черпак летить у тарілку\n10, 10 -> дозвіл вийти з-за столу отримано\n5, 20 -> дозвіл вийти з-за столу отримано\n15, 11 -> ще черпак летить у тарілку",
      "algorithmPlain": "## Алгоритм бабусиної порції\n\nЦей складний соціально-гастрономічний протокол, відомий як Алгоритм бабусиної порції, приймає два числа: недоїдені `грами_на_тарілці_залишилось` та поточний психологічний `рівень_тривоги_бабусі` (1-10). Щоб прийняти стратегічне рішення щодо догодовування, Алгоритм бабусиної порції множить залишок на тривогу. Якщо обчислена загроза голоду становить більше 150, повертає примусову дію \"ще черпак летить у тарілку\", інакше повертає довгоочікуваний вердикт \"дозвіл вийти з-за столу отримано\".",
      "idealMavkaCode": "дія алгоритм(грами_на_тарілці_залишилось, рівень_тривоги_бабусі)\n  турбота = грами_на_тарілці_залишилось * рівень_тривоги_бабусі\n  \n  якщо турбота > 150\n    вернути \"ще черпак летить у тарілку\"\n  інакше\n    вернути \"дозвіл вийти з-за столу отримано\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "a1c744c0-f72a-479d-84c2-b4cf66dd73d2",
    "uuidConflictingDocs": "aca325ad-1537-4309-ae4d-b609c609baf6",
    "uuidFeedback": "72d44193-5bb0-4495-9540-533e688662cf",
    "algorithm": {
      "number": 164,
      "name": "Алгоритм купальського стрибка"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "[8,9,10] -> 3\n[1,2,3,4,5] -> 0\n[7,8,9] -> 2\n[10,10,10,10] -> 4\n[5,6,7,8] -> 1\n[8,8,8] -> 3\n[1,2,3,4,5,6,7,8,9,10] -> 3\n[7,7,7,7] -> 0\n[9,10] -> 2\n[6,7,8,9,10] -> 3",
      "algorithmPlain": "## Алгоритм купальського стрибка\n\nДля реалізації випробування під назвою **Алгоритм купальського стрибка** необхідно завантажити масив цілих чисел `рівень_сміливості_учасників` (де значення варіюються від 1 до 10). Система проводить ітеративну перевірку кожного елемента, підраховуючи лише ті випадки, де значення строго перевищує 7. Результатом роботи, який видає **Алгоритм купальського стрибка**, є числове значення, що відображає кількість сміливців, які стрибнуть, ігноруючи тих, хто вибере стратегію \"ну я наступного разу\".",
      "idealMavkaCode": "дія алгоритм(рівень_сміливості_учасників)\n  хоробрі = 0\n  \n  перебрати рівень_сміливості_учасників як сміливість\n    якщо сміливість > 7\n      хоробрі = хоробрі + 1\n    кінець\n  кінець\n  \n  вернути хоробрі\nкінець"
    }
  },
  {
    "uuid": "50a9384b-6e97-44c9-98ac-e13c729c2d8b",
    "algorithm": {
      "number": 3,
      "name": "Алгоритм вареничного балансу"
    },
    "type": "implement",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "14, 10 -> їсти одно тісто\n15, 10 -> ідеальний вареник\n20, 10 -> ідеальний вареник\n30, 10 -> ідеальний вареник\n31, 10 -> розлізеться при варінні\n10, 10 -> їсти одно тісто\n40, 10 -> розлізеться при варінні\n45, 10 -> розлізеться при варінні\n5, 10 -> їсти одно тісто\n50, 10 -> розлізеться при варінні",
      "algorithmPlain": "## Алгоритм вареничного балансу\n\nВказаний Алгоритм вареничного балансу ініціює свою роботу з отримання двох кількісних показників: `грами_начинки` та `грами_тіста`. Процес передбачає ділення маси начинки на масу тіста. Якщо отриманий коефіцієнт становить менше 1.5, Алгоритм вареничного балансу сигналізує про помилку фразою \"їсти одно тісто\"; якщо ж показник перевищує 3, повертається попередження \"розлізеться при варінні\"; в усіх інших випадках (діапазон норми) результатом є статус \"ідеальний вареник\".",
      "idealMavkaCode": "дія алгоритм(грами_начинки, грами_тіста)\n  якщо грами_тіста == 0\n    вернути \"їсти одно тісто\"\n  кінець\n  \n  відношення = грами_начинки / грами_тіста\n  \n  якщо відношення < 1.5\n    вернути \"їсти одно тісто\"\n  інакше\n    якщо відношення > 3\n      вернути \"розлізеться при варінні\"\n    інакше\n      вернути \"ідеальний вареник\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "72d44193-5bb0-4495-9540-533e688662cf",
    "algorithm": {
      "number": 164,
      "name": "Алгоритм купальського стрибка"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "[8,9,10] -> 3\n[1,2,3,4,5] -> 0\n[7,8,9] -> 2\n[10,10,10,10] -> 4\n[5,6,7,8] -> 1\n[8,8,8] -> 3\n[1,2,3,4,5,6,7,8,9,10] -> 3\n[7,7,7,7] -> 0\n[9,10] -> 2\n[6,7,8,9,10] -> 3",
      "algorithmPlain": "## Алгоритм купальського стрибка\n\nДля реалізації випробування під назвою **Алгоритм купальського стрибка** необхідно завантажити масив цілих чисел `рівень_сміливості_учасників` (де значення варіюються від 1 до 10). Система проводить ітеративну перевірку кожного елемента, підраховуючи лише ті випадки, де значення строго перевищує 7. Результатом роботи, який видає **Алгоритм купальського стрибка**, є числове значення, що відображає кількість сміливців, які стрибнуть, ігноруючи тих, хто вибере стратегію \"ну я наступного разу\".",
      "idealMavkaCode": "дія алгоритм(рівень_сміливості_учасників)\n  хоробрі = 0\n  \n  перебрати рівень_сміливості_учасників як сміливість\n    якщо сміливість > 7\n      хоробрі = хоробрі + 1\n    кінець\n  кінець\n  \n  вернути хоробрі\nкінець"
    }
  },
  {
    "uuid": "6ee04cc7-b417-49af-81b3-85d4dba34e4b",
    "algorithm": {
      "number": 12,
      "name": "Алгоритм сервізної недоторканності"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(рівень_важливості_гостя, кількість_тарілок_у_сервізі)\n  якщо рівень_важливості_гостя < 8 та кількість_тарілок_у_сервізі > 0\n    вернути \"їж з того що є\"\n  кінець\n  \n  якщо рівень_важливості_гостя >= 8\n    вернути \"дістай сервіз\"\n  кінець\n  \n  вернути \"їж з того що є\"\nкінець",
    "isConflicted": false,
    "isAfterFeedback": true,
    "private": {
      "testCases": "1, 10 -> їж з того що є\n7, 15 -> їж з того що є\n8, 1 -> дістай сервіз\n8, 5 -> дістай сервіз\n8, 0 -> їж з того що є\n9, 10 -> дістай сервіз\n10, 1 -> дістай сервіз\n7, 0 -> їж з того що є\n9, 0 -> їж з того що є\n10, 20 -> дістай сервіз",
      "algorithmPlain": "## Алгоритм сервізної недоторканності\n\nСоціально-побутовий Алгоритм сервізної недоторканності аналізує вхідний `рівень_важливості_гостя` (діапазон 1-10) та поточну `кількість_тарілок_у_сервізі`. У випадку, коли важливість візитера менше 8, система рекомендує: \"їж з того що є\". Однак, якщо важливість сягає 8 і вище, а кількість тарілок більше 0, Алгоритм сервізної недоторканності видає команду \"дістай сервіз\", при цьому імперативно зменшує змінну `кількість_тарілок` на 1, передбачаючи неминучі втрати.",
      "idealMavkaCode": "дія алгоритм(рівень_важливості_гостя, кількість_тарілок_у_сервізі)\n  якщо рівень_важливості_гостя < 8\n    вернути \"їж з того що є\"\n  інакше\n    якщо кількість_тарілок_у_сервізі > 0\n      вернути \"дістай сервіз\"\n    інакше\n      вернути \"їж з того що є\"\n    кінець\n  кінець\nкінець"
    }
  },
  {
    "uuid": "013977e5-6ae4-4dd4-bf2b-7e26d9fe2c85",
    "uuidConflictingDocs": "e8693665-85fd-487e-808f-4d595d6297e6",
    "uuidFeedback": "6222e793-69db-46af-82b0-eb447223df6c",
    "algorithm": {
      "number": 112,
      "name": "Алгоритм сервізної недоторканності"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "2, 3 -> їж з того що є\n5, 7 -> мити від пилу півдня\n8, 5 -> мити від пилу півдня\n10, 4 -> мити від пилу півдня\n1, 5 -> їж з того що є\n6, 6 -> мити від пилу півдня\n3, 2 -> їж з того що є\n7, 5 -> мити від пилу півдня\n4, 2 -> їж з того що є\n3, 4 -> дістай, але обережно",
      "algorithmPlain": "## Алгоритм сервізної недоторканності\n\nЩоб вирішити долю парадного святкового посуду, Алгоритм сервізної недоторканності приймає два числа: параметр `офіційність_події` (за шкалою 1-10) та часовий лаг `років_без_використання_сервізу`. Процедура оцінки доцільності, яку впроваджує Алгоритм сервізної недоторканності, множить офіційність на роки простою. Якщо отриманий добуток більше 30, алгоритм повертає факт \"мити від пилу півдня\", якщо менше 10 — повертає рекомендацію \"їж з того що є\", інакше повертає санкцію на використання: \"дістай, але обережно\".",
      "idealMavkaCode": "дія алгоритм(офіційність, роки)\n  результат = офіційність * роки\n  \n  якщо результат > 30\n    вернути \"мити від пилу півдня\"\n  кінець\n  \n  якщо результат < 10\n    вернути \"їж з того що є\"\n  кінець\n  \n  вернути \"дістай, але обережно\"\nкінець"
    }
  },
  {
    "uuid": "58d1dd19-9212-4a53-874e-4d4aed95915a",
    "algorithm": {
      "number": 134,
      "name": "Алгоритм \"на безриб'ї і рак риба\""
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "1, 7 -> зліпимо й так, гості зрозуміють\n1, 6 -> біжи до сусідки за маслечком, не ганьби хату\n2, 8 -> зліпимо й так, гості зрозуміють\n0, 7 -> біжи до сусідки за маслечком, не ганьби хату\n1, 10 -> зліпимо й так, гості зрозуміють\n3, 5 -> біжи до сусідки за маслечком, не ганьби хату\n1, 9 -> зліпимо й так, гості зрозуміють\n5, 7 -> зліпимо й так, гості зрозуміють\n0, 10 -> біжи до сусідки за маслечком, не ганьби хату\n2, 6 -> біжи до сусідки за маслечком, не ганьби хату",
      "algorithmPlain": "## Алгоритм \"на безриб'ї і рак риба\"\n\nКулінарний Алгоритм \"на безриб'ї і рак риба\" оцінює `наявність_маргарину` та `рівень_потреби_в_пиріжках` (шкала 1-10). Логіка спрацьовує так: якщо потреба перевищує 6, а маргарину є хоча б 1, то \"на безриб'ї і рак риба\" вирішує \"зліпимо й так, гості зрозуміють\". Інакше система вимагає: \"біжи до сусідки за маслечком, не ганьби хату\".",
      "idealMavkaCode": "дія алгоритм(наявність_маргарину, рівень_потреби_в_пиріжках)\n  якщо рівень_потреби_в_пиріжках > 6\n    якщо наявність_маргарину >= 1\n      вернути \"зліпимо й так, гості зрозуміють\"\n    інакше\n      вернути \"біжи до сусідки за маслечком, не ганьби хату\"\n    кінець\n  інакше\n    вернути \"біжи до сусідки за маслечком, не ганьби хату\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "ec8149f7-7eb6-4d82-bf1c-deafc3d80f05",
    "algorithm": {
      "number": 171,
      "name": "Алгоритм святкової куті"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "[1,2,3,4,5] -> баба Параска схвалює\n[1,0,3,4,5] -> це не кутя, це каша\n[0,0,0] -> це не кутя, це каша\n[5,5,5,5] -> баба Параска схвалює\n[1,2,3,0] -> це не кутя, це каша\n[10,20,30] -> баба Параска схвалює\n[0] -> це не кутя, це каша\n[1] -> баба Параска схвалює\n[7,8,9,10,11] -> баба Параска схвалює\n[3,3,0,3,3] -> це не кутя, це каша",
      "algorithmPlain": "## Алгоритм святкової куті\n\nКулінарний **Алгоритм святкової куті** здійснює перевірку масиву `кількість_інгредієнтів_кожного`. Суть процесу полягає у підрахунку кількості елементів, що мають нульове значення. Якщо виявлено хоча б один такий випадок (кількість нулів більше 0), алгоритм виносить розгромний вердикт \"це не кутя, це каша\". Якщо ж всі інгредієнти присутні, **Алгоритм святкової куті** повідомляє, що \"баба Параска схвалює\".",
      "idealMavkaCode": "дія алгоритм(кількість_інгредієнтів_кожного)\n  має_нуль = 0\n  \n  перебрати кількість_інгредієнтів_кожного як елемент\n    якщо елемент == 0\n      має_нуль = 1\n    кінець\n  кінець\n  \n  якщо має_нуль == 1\n    вернути \"це не кутя, це каша\"\n  інакше\n    вернути \"баба Параска схвалює\"\n  кінець\nкінець"
    }
  },
  {
    "uuid": "0ed7abc6-ecae-47bd-8147-2004cc16f0e0",
    "uuidConflictingDocs": "3d30be99-b901-44ab-8da7-c0a27d3fc32c",
    "uuidFeedback": "2fb243f0-a2b0-4b44-a24d-ab1152376c41",
    "algorithm": {
      "number": 103,
      "name": "Алгоритм вареничного балансу"
    },
    "type": "review",
    "mavkaCodeToReview": "дія алгоритм(зліплених_вареників, кількість_їдців)\n  коефіцієнт = зліплених_вареників / кількість_їдців\n  \n  якщо коефіцієнт < 12\n    вернути \"це на один зуб\"\n  кінець\n  \n  якщо коефіцієнт > 30\n    вернути \"заморожуй решту\"\n  кінець\n  \n  вернути \"всім вистачить і ще попросять\"\nкінець",
    "isConflicted": true,
    "isAfterFeedback": false,
    "private": {
      "testCases": "10, 1 -> це на один зуб\n50, 10 -> це на один зуб\n100, 10 -> це на один зуб\n120, 10 -> всім вистачить і ще попросять\n150, 10 -> всім вистачить і ще попросять\n200, 10 -> всім вистачить і ще попросять\n320, 10 -> заморожуй решту\n400, 10 -> заморожуй решту\n150, 10 -> всім вистачить і ще попросять\n350, 10 -> заморожуй решту",
      "algorithmPlain": "## Алгоритм вареничного балансу\n\nЦей розподільчий обчислювальний метод, іменований як Алгоритм вареничного балансу, розпочинає свою роботу, коли приймає два числа: загальне число `зліплених_вареників` та `кількість_їдців`, що претендують на обід. Ключова математична операція, яку виконує Алгоритм вареничного балансу, — це ділення вареників на їдців для визначення індивідуальної квоти. Якщо розрахована частка становить менше 12, функція повертає попередження \"це на один зуб\", якщо ж результат виявляється більше 30, повертає рекомендацію \"заморожуй решту\", а інакше (в межах гастрономічної норми) повертає заспокійливе \"всім вистачить і ще попросять\".",
      "idealMavkaCode": "дія алгоритм(зліплених_вареників, кількість_їдців)\n  коефіцієнт = зліплених_вареників / кількість_їдців\n  \n  якщо коефіцієнт < 12\n    вернути \"це на один зуб\"\n  кінець\n  \n  якщо коефіцієнт > 30\n    вернути \"заморожуй решту\"\n  кінець\n  \n  вернути \"всім вистачить і ще попросять\"\nкінець"
    }
  },
  {
    "uuid": "60eecfbf-9d2f-49d0-9577-474958b075ef",
    "algorithm": {
      "number": 106,
      "name": "Алгоритм часникової пампушки"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "2, 5 -> часник шматками плаває\n3, 8 -> ще потовчи в ступці\n5, 7 -> ще потовчи в ступці\n2, 10 -> ще потовчи в ступці\n1, 15 -> часник шматками плаває\n10, 7 -> соус ідеальний\n8, 8 -> соус ідеальний\n2, 2 -> часник шматками плаває\n6, 6 -> ще потовчи в ступці\n15, 5 -> соус ідеальний",
      "algorithmPlain": "## Алгоритм часникової пампушки\n\nДля точного визначення консистенції заправки Алгоритм часникової пампушки на вході приймає два числа: кількість `зубчики_часнику` та механічний параметр `сила_подрібнення` (в діапазоні 1-10). Основне обчислення, яке проводить Алгоритм часникової пампушки, полягає в тому, що він множить часник на силу для отримання індексу однорідності. Аналіз результату виглядає так: якщо добуток менше 20, повертає \"часник шматками плаває\"; якщо значення більше 60, повертає схвальне \"соус ідеальний\"; інакше, при отриманні проміжних значень, повертає пораду \"ще потовчи в ступці\".",
      "idealMavkaCode": "дія алгоритм(зубчики_часнику, сила_подрібнення)\n  результат = зубчики_часнику * сила_подрібнення\n  \n  якщо результат < 20\n    вернути \"часник шматками плаває\"\n  кінець\n  \n  якщо результат > 60\n    вернути \"соус ідеальний\"\n  кінець\n  \n  вернути \"ще потовчи в ступці\"\nкінець"
    }
  },
  {
    "uuid": "2fb243f0-a2b0-4b44-a24d-ab1152376c41",
    "algorithm": {
      "number": 103,
      "name": "Алгоритм вареничного балансу"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "10, 1 -> це на один зуб\n50, 10 -> це на один зуб\n100, 10 -> це на один зуб\n120, 10 -> всім вистачить і ще попросять\n150, 10 -> всім вистачить і ще попросять\n200, 10 -> всім вистачить і ще попросять\n320, 10 -> заморожуй решту\n400, 10 -> заморожуй решту\n150, 10 -> всім вистачить і ще попросять\n350, 10 -> заморожуй решту",
      "algorithmPlain": "## Алгоритм вареничного балансу\n\nЦей розподільчий обчислювальний метод, іменований як Алгоритм вареничного балансу, розпочинає свою роботу, коли приймає два числа: загальне число `зліплених_вареників` та `кількість_їдців`, що претендують на обід. Ключова математична операція, яку виконує Алгоритм вареничного балансу, — це ділення вареників на їдців для визначення індивідуальної квоти. Якщо розрахована частка становить менше 12, функція повертає попередження \"це на один зуб\", якщо ж результат виявляється більше 30, повертає рекомендацію \"заморожуй решту\", а інакше (в межах гастрономічної норми) повертає заспокійливе \"всім вистачить і ще попросять\".",
      "idealMavkaCode": "дія алгоритм(зліплених_вареників, кількість_їдців)\n  коефіцієнт = зліплених_вареників / кількість_їдців\n  \n  якщо коефіцієнт < 12\n    вернути \"це на один зуб\"\n  кінець\n  \n  якщо коефіцієнт > 30\n    вернути \"заморожуй решту\"\n  кінець\n  \n  вернути \"всім вистачить і ще попросять\"\nкінець"
    }
  },
  {
    "uuid": "6222e793-69db-46af-82b0-eb447223df6c",
    "algorithm": {
      "number": 112,
      "name": "Алгоритм сервізної недоторканності"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "2, 3 -> їж з того що є\n5, 7 -> мити від пилу півдня\n8, 5 -> мити від пилу півдня\n10, 4 -> мити від пилу півдня\n1, 5 -> їж з того що є\n6, 6 -> мити від пилу півдня\n3, 2 -> їж з того що є\n7, 5 -> мити від пилу півдня\n4, 2 -> їж з того що є\n3, 4 -> дістай, але обережно",
      "algorithmPlain": "## Алгоритм сервізної недоторканності\n\nЩоб вирішити долю парадного святкового посуду, Алгоритм сервізної недоторканності приймає два числа: параметр `офіційність_події` (за шкалою 1-10) та часовий лаг `років_без_використання_сервізу`. Процедура оцінки доцільності, яку впроваджує Алгоритм сервізної недоторканності, множить офіційність на роки простою. Якщо отриманий добуток більше 30, алгоритм повертає факт \"мити від пилу півдня\", якщо менше 10 — повертає рекомендацію \"їж з того що є\", інакше повертає санкцію на використання: \"дістай, але обережно\".",
      "idealMavkaCode": "дія алгоритм(офіційність, роки)\n  результат = офіційність * роки\n  \n  якщо результат > 30\n    вернути \"мити від пилу півдня\"\n  кінець\n  \n  якщо результат < 10\n    вернути \"їж з того що є\"\n  кінець\n  \n  вернути \"дістай, але обережно\"\nкінець"
    }
  },
  {
    "uuid": "be00ebf6-2e54-4664-a819-3b535539950c",
    "algorithm": {
      "number": 119,
      "name": "Алгоритм шкварчання шкварок"
    },
    "type": "implement",
    "isConflicted": true,
    "isAfterFeedback": true,
    "private": {
      "testCases": "50, 1 -> жуватимеш довго\n50, 5 -> хрустить на весь двір\n90, 10 -> тоне у власному соку\n30, 2 -> жуватимеш довго\n60, 5 -> хрустить на весь двір\n100, 10 -> тоне у власному соку\n80, 4 -> хрустить на весь двір\n60, 2 -> жуватимеш довго\n70, 12 -> тоне у власному соку\n50, 6 -> хрустить на весь двір",
      "algorithmPlain": "## Алгоритм шкварчання шкварок\n\nДля досягнення ідеальної смакової кондиції сала Алгоритм шкварчання шкварок приймає два числа: `відсоток_жиру_в_салі` та термічну тривалість `хвилин_на_вогні`. Специфічні обчислення, які виконує Алгоритм шкварчання шкварок, виглядають так: він спершу множить жир на хвилини і ділить на 10 отриманий добуток. Якщо фінальний індекс витоплювання менше 25, повертає \"жуватимеш довго\", якщо більше 80 — повертає \"тоне у власному соку\", інакше (при золотому стандарті) повертає \"хрустить на весь двір\".",
      "idealMavkaCode": "дія алгоритм(відсоток_жиру_в_салі, хвилин_на_вогні)\n  шкварчання = (відсоток_жиру_в_салі * хвилин_на_вогні) / 10\n  \n  якщо шкварчання < 25\n    вернути \"жуватимеш довго\"\n  кінець\n  \n  якщо шкварчання > 80\n    вернути \"тоне у власному соку\"\n  кінець\n  \n  вернути \"хрустить на весь двір\"\nкінець"
    }
  }
]
